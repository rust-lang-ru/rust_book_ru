<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <title>Обедающие философы</title>

    <link rel="stylesheet" type="text/css" href="../rustbook.css">

    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    
                <div id="nav">
                    <button id="toggle-nav">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                        <span class="bar"></span>
                    </button>
                </div>
<div id='toc' class='mobile-hidden'>
<ol class='chapter'>
<li><a  href='../README.html'><b>1.</b> Introduction</a>
</li>
<li><a  href='../src/INTRODUCTION.html'><b>2.</b> Введение</a>
</li>
<li><a  href='../src/getting-started.html'><b>3.</b> C чего начать</a>
</li>
<li><a  href='../src/learn-rust.html'><b>4.</b> Изучение Rust</a>
<ol class='section'>
<li><a  href='../src/guessing-game.html'><b>4.1.</b> Угадайка</a>
</li>
<li><a class='active' href='../src/dining-philosophers.html'><b>4.2.</b> Обедающие философы</a>
</li>
<li><a  href='../src/rust-inside-other-languages.html'><b>4.3.</b> Вызов кода на Rust из других языков</a>
</li>
</ol>
</li>
<li><a  href='../src/syntax-and-semantics.html'><b>5.</b> Синтаксис и семантика</a>
<ol class='section'>
<li><a  href='../src/variable-bindings.html'><b>5.1.</b> Связывание имён</a>
</li>
<li><a  href='../src/functions.html'><b>5.2.</b> Функции</a>
</li>
<li><a  href='../src/primitive-types.html'><b>5.3.</b> Простые типы</a>
</li>
<li><a  href='../src/comments.html'><b>5.4.</b> Комментарии</a>
</li>
<li><a  href='../src/if.html'><b>5.5.</b> Конструкция `if`</a>
</li>
<li><a  href='../src/loops.html'><b>5.6.</b> Циклы</a>
</li>
<li><a  href='../src/ownership.html'><b>5.7.</b> Владение</a>
</li>
<li><a  href='../src/references-and-borrowing.html'><b>5.8.</b> Ссылки и заимствование</a>
</li>
<li><a  href='../src/lifetimes.html'><b>5.9.</b> Время жизни</a>
</li>
<li><a  href='../src/mutability.html'><b>5.10.</b> Изменяемость</a>
</li>
<li><a  href='../src/structs.html'><b>5.11.</b> Структуры</a>
</li>
<li><a  href='../src/enums.html'><b>5.12.</b> Перечисления</a>
</li>
<li><a  href='../src/match.html'><b>5.13.</b> Конструкция `match`</a>
</li>
<li><a  href='../src/patterns.html'><b>5.14.</b> Шаблоны сопоставления `match`</a>
</li>
<li><a  href='../src/method-syntax.html'><b>5.15.</b> Синтаксис методов</a>
</li>
<li><a  href='../src/vectors.html'><b>5.16.</b> Вектора</a>
</li>
<li><a  href='../src/strings.html'><b>5.17.</b> Строки</a>
</li>
<li><a  href='../src/generics.html'><b>5.18.</b> Обобщённое программирование</a>
</li>
<li><a  href='../src/traits.html'><b>5.19.</b> Типажи</a>
</li>
<li><a  href='../src/drop.html'><b>5.20.</b> Типаж `Drop`</a>
</li>
<li><a  href='../src/if-let.html'><b>5.21.</b> Конструкция `if let`</a>
</li>
<li><a  href='../src/trait-objects.html'><b>5.22.</b> Типажи-объекты</a>
</li>
<li><a  href='../src/closures.html'><b>5.23.</b> Замыкания</a>
</li>
<li><a  href='../src/ufcs.html'><b>5.24.</b> Универсальный синтаксис вызова функций</a>
</li>
<li><a  href='../src/crates-and-modules.html'><b>5.25.</b> Контейнеры и модули</a>
</li>
<li><a  href='../src/const-and-static.html'><b>5.26.</b> `const` и `static`</a>
</li>
<li><a  href='../src/attributes.html'><b>5.27.</b> Атрибуты</a>
</li>
<li><a  href='../src/type-aliases.html'><b>5.28.</b> Псевдонимы типов</a>
</li>
<li><a  href='../src/casting-between-types.html'><b>5.29.</b> Приведение типов</a>
</li>
<li><a  href='../src/associated-types.html'><b>5.30.</b> Ассоциированные типы</a>
</li>
<li><a  href='../src/unsized-types.html'><b>5.31.</b> Безразмерные типы</a>
</li>
<li><a  href='../src/operators-and-overloading.html'><b>5.32.</b> Перегрузка операций</a>
</li>
<li><a  href='../src/deref-coercions.html'><b>5.33.</b> Преобразования при разыменовании</a>
</li>
<li><a  href='../src/macros.html'><b>5.34.</b> Макросы</a>
</li>
<li><a  href='../src/raw-pointers.html'><b>5.35.</b> Сырые указатели</a>
</li>
<li><a  href='../src/unsafe.html'><b>5.36.</b> Небезопасный код</a>
</li>
</ol>
</li>
<li><a  href='../src/effective-rust.html'><b>6.</b> Эффективное использование Rust</a>
<ol class='section'>
<li><a  href='../src/the-stack-and-the-heap.html'><b>6.1.</b> Стек и куча</a>
</li>
<li><a  href='../src/testing.html'><b>6.2.</b> Тестирование</a>
</li>
<li><a  href='../src/conditional-compilation.html'><b>6.3.</b> Условная компиляция</a>
</li>
<li><a  href='../src/documentation.html'><b>6.4.</b> Документация</a>
</li>
<li><a  href='../src/iterators.html'><b>6.5.</b> Итераторы</a>
</li>
<li><a  href='../src/concurrency.html'><b>6.6.</b> Многозадачность</a>
</li>
<li><a  href='../src/error-handling.html'><b>6.7.</b> Обработка ошибок</a>
</li>
<li><a  href='../src/choosing-your-guarantees.html'><b>6.8.</b> Выбор гарантий</a>
</li>
<li><a  href='../src/ffi.html'><b>6.9.</b> Интерфейс внешних функций</a>
</li>
<li><a  href='../src/borrow-and-asref.html'><b>6.10.</b> Типажи `Borrow` и `AsRef`</a>
</li>
<li><a  href='../src/release-channels.html'><b>6.11.</b> Каналы сборок</a>
</li>
<li><a  href='../src/using-rust-without-the-standard-library.html'><b>6.12.</b> Using Rust without the standard library</a>
</li>
</ol>
</li>
<li><a  href='../src/nightly-rust.html'><b>7.</b> Нестабильные возможности Rust</a>
<ol class='section'>
<li><a  href='../src/compiler-plugins.html'><b>7.1.</b> Плагины к компилятору</a>
</li>
<li><a  href='../src/inline-assembly.html'><b>7.2.</b> Встроенный ассемблерный код</a>
</li>
<li><a  href='../src/no-stdlib.html'><b>7.3.</b> Без stdlib</a>
</li>
<li><a  href='../src/intrinsics.html'><b>7.4.</b> Внутренние средства</a>
</li>
<li><a  href='../src/lang-items.html'><b>7.5.</b> Элементы языка</a>
</li>
<li><a  href='../src/advanced-linking.html'><b>7.6.</b> Продвинутое руководство по компоновке</a>
</li>
<li><a  href='../src/benchmark-tests.html'><b>7.7.</b> Тесты производительности</a>
</li>
<li><a  href='../src/box-syntax-and-patterns.html'><b>7.8.</b> Синтаксис упаковки и шаблоны `match`</a>
</li>
<li><a  href='../src/slice-patterns.html'><b>7.9.</b> Шаблоны `match` для срезов</a>
</li>
<li><a  href='../src/associated-constants.html'><b>7.10.</b> Ассоциированные константы</a>
</li>
<li><a  href='../src/custom-allocators.html'><b>7.11.</b> Пользовательские менеджеры памяти</a>
</li>
</ol>
</li>
<li><a  href='../src/glossary.html'><b>8.</b> Глоссарий</a>
</li>
<li><a  href='../src/syntax-index.html'><b>9.</b> Syntax Index</a>
</li>
<li><a  href='../src/bibliography.html'><b>10.</b> Библиография</a>
</li>
</ol>
</div>
<div id='page-wrapper'>
<div id='page'>


    <h1 class="title">Обедающие философы</h1>
    <p>Для нашего второго проекта мы выбрали классическую задачу с параллелизмом. Она
называется «Обедающие философы». Задача была сформулирована в 1965 году Эдсгером
Дейкстрой, но мы будем использовать версию задачи, <a href="http://www.usingcsp.com/cspbook.pdf">адаптированную</a> в
1985 году Ричардом Хоаром.</p>

<blockquote>
<p>В древние времена богатые филантропы пригласили погостить пятерых выдающихся
философов. Им выделили каждому по комнате, в которой они могли заниматься
своей профессиональной деятельностью — мышлением. Также была общая столовая,
где стоял большой круглый стол, а вокруг него пять стульев. Каждый стул имел
табличку с именем философа, который должен был сидеть на нем. Слева от каждого
философа лежала золотая вилка, а в центре стола стояла большая миска со
спагетти, которая постоянно пополнялась. Как подобает философам, они большую
часть своего времени проводили в раздумьях. Но однажды они почувствовали голод
и отправились в столовую. Каждый сел на свой стул, взял по вилке и воткнул её
в миску со спагетти. Но сущность запутанных спагетти такова, что необходима
вторая вилка, чтобы отправлять спагетти в рот. То есть философу требовалась
ещё и вилка справа от него. Философы положили свои вилки и встали из-за стола,
продолжая думать. Ведь вилка может быть использована только одним философом
одновременно. Если другой философ захочет её взять, то ему придётся ждать
когда она освободится.</p>
</blockquote>

<p>Эта классическая задача показывает различные элементы параллелизма. Сложность
реализации задачи состоит в том, что простая реализация может зайти в
безвыходное состояние. Давайте рассмотрим простой пример решения этой проблемы:</p>

<ol>
<li>Философ берет вилку в свою левую руку.</li>
<li>Затем берет вилку в свою правую руку.</li>
<li>Ест.</li>
<li>Кладёт вилки на место.</li>
</ol>

<p>Теперь представим это как последовательность действий философов:</p>

<ol>
<li>Философ 1 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 2 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 3 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 4 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>Философ 5 начинает выполнять алгоритм, берет вилку в левую руку.</li>
<li>...? Все вилки заняты и никто не может начать есть! Безвыходное состояние.</li>
</ol>

<p>Есть различные пути решения этой задачи. Мы в этом руководстве покажем своё
решение. Сначала давайте создадим проект с помощью <code>cargo</code>:</p>

<pre><code class="language-bash">$ cd ~/projects
$ cargo new dining_philosophers --bin
$ cd dining_philosophers
</code></pre>

<p>Теперь мы можем начать моделирование задачи. Начнём с философов в <code>src/main.rs</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Philosopher</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Philosopher</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {
        <span class='ident'>Philosopher</span> {
            <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
        }
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>p1</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Джудит Батлер&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p2</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Рая Дунаевская&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p3</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Зарубина Наталья&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p4</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Эмма Гольдман&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p5</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Анна Шмидт&quot;</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=struct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0A%0Aimpl%20Philosopher%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20p1%20%3D%20Philosopher%3A%3Anew(%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22)%3B%0A%20%20%20%20let%20p2%20%3D%20Philosopher%3A%3Anew(%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22)%3B%0A%20%20%20%20let%20p3%20%3D%20Philosopher%3A%3Anew(%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22)%3B%0A%20%20%20%20let%20p4%20%3D%20Philosopher%3A%3Anew(%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22)%3B%0A%20%20%20%20let%20p5%20%3D%20Philosopher%3A%3Anew(%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22)%3B%0A%7D%0A">Run</a></pre>

<p>Здесь мы создаём <a href="structs.html"><code>struct</code></a>, представляющую философа. На данный момент
нам нужно всего лишь имя. Мы выбрали тип <a href="strings.html"><code>String</code></a>, а не <code>&amp;str</code> для
хранения имени. Обычно проще работать с типом, владеющим данными, чем с типом,
использующим ссылки.</p>

<p>Продолжим:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>impl</span> <span class='ident'>Philosopher</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {
        <span class='ident'>Philosopher</span> {
            <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
        }
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0Aimpl%20Philosopher%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Этот блок <code>impl</code> позволяет объявить что-либо для структуры <code>Philosopher</code>. В
нашем случае мы объявляем «статическую функцию» <code>new</code>. Первая строка этой
функции выглядит так:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0Aimpl%20Philosopher%20%7B%0Afn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Она принимает один аргумент, <code>name</code>, типа <code>&amp;str</code>. Это ссылка на другую строку.
Она возвращает новый экземпляр нашей структуры <code>Philosopher</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>Philosopher</span> {
    <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0Aimpl%20Philosopher%20%7B%0A%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0APhilosopher%20%7B%0A%20%20%20%20name%3A%20name.to_string()%2C%0A%7D%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Этот код создаёт новый экземпляр <code>Philosopher</code> и присваивает его полю <code>name</code>
значение переданного аргумента <code>name</code>. Но используется не сам аргумент, а
результат вызова его метода <code>.to_string()</code>. Этот вызов создаёт копию строки, на
которую указывает наш <code>&amp;str</code>, и возвращает новый экземпляр <code>String</code>, который и
будет присвоен полю <code>name</code> структуры <code>Philosopher</code>.</p>

<p>Почему бы сразу не передавать строку типа <code>String</code> напрямую? Так легче её
вызывать. Если бы мы принимали тип <code>String</code>, а тот, кто вызывает функцию, имел
бы ссылку на строку, <code>&amp;str</code>, то ему пришлось бы приводить её к типу <code>String</code>
перед каждым вызовом. Это уменьшит гибкость кода, и мы будем вынуждены <em>каждый
раз</em> создавать копию строки. Для этой небольшой программы это не очень важно,
так как мы знаем, что будем использовать только короткие строки.</p>

<p>И последнее на что следует обратить внимание: мы просто объявляем структуру
<code>Philosopher</code> и кажется, что ничего больше не делаем. Rust — это язык
программирования, «ориентированный на выражения», что означает, что каждое
выражение возвращает значение. Это верно и для функций, у которых автоматически
возвращается последнее выражение. Так как в нашем примере в последнем выражении
функции мы создаём структуру <code>Philosopher</code>, то она и будет возвращена функцией.</p>

<p>Имя функции <code>new()</code> не регламентируется Rust. Это просто соглашение об
именовании функций, которые возвращают новые экземпляры структур. Давайте снова
посмотрим на функцию <code>main()</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>p1</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Джудит Батлер&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p2</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Рая Дунаевская&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p3</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Зарубина Наталья&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p4</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Эмма Гольдман&quot;</span>);
    <span class='kw'>let</span> <span class='ident'>p5</span> <span class='op'>=</span> <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Анна Шмидт&quot;</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=struct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0A%0Aimpl%20Philosopher%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20p1%20%3D%20Philosopher%3A%3Anew(%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22)%3B%0A%20%20%20%20let%20p2%20%3D%20Philosopher%3A%3Anew(%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22)%3B%0A%20%20%20%20let%20p3%20%3D%20Philosopher%3A%3Anew(%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22)%3B%0A%20%20%20%20let%20p4%20%3D%20Philosopher%3A%3Anew(%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22)%3B%0A%20%20%20%20let%20p5%20%3D%20Philosopher%3A%3Anew(%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22)%3B%0A%7D%0A">Run</a></pre>

<p>Здесь мы связываем пять имён переменных с пятью новыми философами. Если бы
мы <em>не объявили</em> свою реализацию функции <code>new()</code>, то наш код выглядел бы так:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>p1</span> <span class='op'>=</span> <span class='ident'>Philosopher</span> { <span class='ident'>name</span>: <span class='string'>&quot;Джудит Батлер&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>p2</span> <span class='op'>=</span> <span class='ident'>Philosopher</span> { <span class='ident'>name</span>: <span class='string'>&quot;Рая Дунаевская&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>p3</span> <span class='op'>=</span> <span class='ident'>Philosopher</span> { <span class='ident'>name</span>: <span class='string'>&quot;Зарубина Наталья&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>p4</span> <span class='op'>=</span> <span class='ident'>Philosopher</span> { <span class='ident'>name</span>: <span class='string'>&quot;Эмма Гольдман&quot;</span>.<span class='ident'>to_string</span>() };
    <span class='kw'>let</span> <span class='ident'>p5</span> <span class='op'>=</span> <span class='ident'>Philosopher</span> { <span class='ident'>name</span>: <span class='string'>&quot;Анна Шмидт&quot;</span>.<span class='ident'>to_string</span>() };
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=struct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0Afn%20main()%20%7B%0A%20%20%20%20let%20p1%20%3D%20Philosopher%20%7B%20name%3A%20%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22.to_string()%20%7D%3B%0A%20%20%20%20let%20p2%20%3D%20Philosopher%20%7B%20name%3A%20%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22.to_string()%20%7D%3B%0A%20%20%20%20let%20p3%20%3D%20Philosopher%20%7B%20name%3A%20%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22.to_string()%20%7D%3B%0A%20%20%20%20let%20p4%20%3D%20Philosopher%20%7B%20name%3A%20%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22.to_string()%20%7D%3B%0A%20%20%20%20let%20p5%20%3D%20Philosopher%20%7B%20name%3A%20%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22.to_string()%20%7D%3B%0A%7D%0A">Run</a></pre>

<p>Этот код выглядит не слишком изящно. Использование статической функции <code>new</code>
имеет и другие преимущества, но даже в этом простом случае, её использование
было оправдано.</p>

<p>Теперь у нас уже есть каркас программы, и можно заняться решением задачи с
обедающими философами. Начнём с конца: сделаем так, чтобы философ сообщал нам,
когда он закончит есть. Для этого потребуется метод, сообщающий нам об окончании
приёма пищи, и цикл, запускающий этот метод для каждого философа.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Philosopher</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Philosopher</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {
        <span class='ident'>Philosopher</span> {
            <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} закончила есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>philosophers</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Джудит Батлер&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Рая Дунаевская&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Зарубина Наталья&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Эмма Гольдман&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Анна Шмидт&quot;</span>),
    ];

    <span class='kw'>for</span> <span class='ident'>p</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>philosophers</span> {
        <span class='ident'>p</span>.<span class='ident'>eat</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=struct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0A%0Aimpl%20Philosopher%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20philosophers%20%3D%20vec!%5B%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22)%2C%0A%20%20%20%20%5D%3B%0A%0A%20%20%20%20for%20p%20in%20%26philosophers%20%7B%0A%20%20%20%20%20%20%20%20p.eat()%3B%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Давайте сначала рассмотрим функцию <code>main()</code>. Вместо того чтобы создавать пять
отдельных связанных имён для философов, мы создаём для них <code>Vec&lt;T&gt;</code>. <code>Vec&lt;T&gt;</code>
называют «вектор», он является расширяемой версией массива. Затем в цикле
<a href="loops.html#for"><code>for</code></a> мы перебираем вектор, получая ссылку на очередного философа на
каждой итерации.</p>

<p>В теле цикла мы вызываем метод <code>p.eat()</code>, который объявлен выше:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} закончила есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20eat(%26self)%20%7B%0A%20%20%20%20println!(%22%7B%7D%20%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%7D%0A%7D">Run</a></pre>

<p>В Rust методы явно получают параметр <code>self</code>. Вот почему <code>eat()</code> является
методом, а <code>new</code> — статической функцией: <code>new()</code> не получает параметр <code>self</code>.
Для нашей первой версии метода <code>eat()</code> мы выводим только имя философа и
сообщение о том, что он закончил есть. Запустив эту программу вы получите:</p>

<pre><code class="language-text">Джудит Батлер закончила есть.
Рая Дунаевская закончила есть.
Зарубина Наталья закончила есть.
Эмма Гольдман закончила есть.
Анна Шмидт закончила есть.
</code></pre>

<p>Это было не сложно! Осталось чуть-чуть и приступим к самой задаче.</p>

<p>Дальше нам нужно сделать так, чтобы философы не только заканчивали, но и
начинали есть. Это новая версия программы:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>struct</span> <span class='ident'>Philosopher</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Philosopher</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {
        <span class='ident'>Philosopher</span> {
            <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} начала есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>1000</span>));

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} закончила есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>philosophers</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Джудит Батлер&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Рая Дунаевская&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Зарубина Наталья&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Эмма Гольдман&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Анна Шмидт&quot;</span>),
    ];

    <span class='kw'>for</span> <span class='ident'>p</span> <span class='kw'>in</span> <span class='kw-2'>&amp;</span><span class='ident'>philosophers</span> {
        <span class='ident'>p</span>.<span class='ident'>eat</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Athread%3B%0Ause%20std%3A%3Atime%3A%3ADuration%3B%0A%0Astruct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0A%0Aimpl%20Philosopher%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%0A%20%20%20%20%20%20%20%20thread%3A%3Asleep(Duration%3A%3Afrom_millis(1000))%3B%0A%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20philosophers%20%3D%20vec!%5B%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22)%2C%0A%20%20%20%20%5D%3B%0A%0A%20%20%20%20for%20p%20in%20%26philosophers%20%7B%0A%20%20%20%20%20%20%20%20p.eat()%3B%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Появились некоторые небольшие изменения. Давайте посмотрим, что же изменилось:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Athread%3B%0A%7D">Run</a></pre>

<p>Конструкция <code>use</code> предоставляет доступ к области видимости модуля <code>thread</code> из
стандартной библиотеки. Мы собираемся использовать этот модуль далее в коде, и
поэтому нам нужно объявить о его использовании.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} начала есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>1000</span>));

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} закончила есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);
    }<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%0A%20%20%20%20%20%20%20%20thread%3A%3Asleep(Duration%3A%3Afrom_millis(1000))%3B%0A%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%20%20%20%20%7D%0A%7D">Run</a></pre>

<p>Здесь мы выводим на экран два сообщения и вызываем функцию <code>sleep</code> между
ними. Эта функция останавливает рабочий поток на 1000 миллисекунд, что
симулирует процесс приёма пищи философа.</p>

<p>Если вы запустите программу теперь, то увидите, что каждый философ, по очереди,
начинает есть, ест какое-то время и заканчивает есть:</p>

<pre><code class="language-text">Джудит Батлер начала есть.
Джудит Батлер закончила есть.
Рая Дунаевская начала есть.
Рая Дунаевская закончила есть.
Зарубина Наталья начала есть.
Зарубина Наталья закончила есть.
Эмма Гольдман начала есть.
Эмма Гольдман закончила есть.
Анна Шмидт начала есть.
Анна Шмидт закончила есть.
</code></pre>

<p>Превосходно! Теперь у нас осталась только одна проблема: наши философы едят по
очереди, а не одновременно, то есть мы пока не решили задачу параллелизма.</p>

<p>Для того, чтобы наши философы начали есть одновременно, нам нужно внести
некоторые изменения в код:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;

<span class='kw'>struct</span> <span class='ident'>Philosopher</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
}

<span class='kw'>impl</span> <span class='ident'>Philosopher</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {
        <span class='ident'>Philosopher</span> {
            <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
        }
    }

    <span class='kw'>fn</span> <span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>) {
        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} начала есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>1000</span>));

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} закончила есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);
    }
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>philosophers</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Джудит Батлер&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Рая Дунаевская&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Зарубина Наталья&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Эмма Гольдман&quot;</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Анна Шмидт&quot;</span>),
    ];

    <span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>philosophers</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> {
        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>p</span>.<span class='ident'>eat</span>();
        })
    }).<span class='ident'>collect</span>();

    <span class='kw'>for</span> <span class='ident'>h</span> <span class='kw'>in</span> <span class='ident'>handles</span> {
        <span class='ident'>h</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Athread%3B%0Ause%20std%3A%3Atime%3A%3ADuration%3B%0A%0Astruct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%7D%0A%0Aimpl%20Philosopher%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20eat(%26self)%20%7B%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%0A%20%20%20%20%20%20%20%20thread%3A%3Asleep(Duration%3A%3Afrom_millis(1000))%3B%0A%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20philosophers%20%3D%20vec!%5B%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22)%2C%0A%20%20%20%20%5D%3B%0A%0A%20%20%20%20let%20handles%3A%20Vec%3C_%3E%20%3D%20philosophers.into_iter().map(%7Cp%7C%20%7B%0A%20%20%20%20%20%20%20%20thread%3A%3Aspawn(move%20%7C%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20p.eat()%3B%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%7D).collect()%3B%0A%0A%20%20%20%20for%20h%20in%20handles%20%7B%0A%20%20%20%20%20%20%20%20h.join().unwrap()%3B%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Мы добавили ещё один цикл в функцию <code>main()</code>. Теперь она выглядит так:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>philosophers</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> {
    <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
        <span class='ident'>p</span>.<span class='ident'>eat</span>();
    })
}).<span class='ident'>collect</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20handles%3A%20Vec%3C_%3E%20%3D%20philosophers.into_iter().map(%7Cp%7C%20%7B%0A%20%20%20%20thread%3A%3Aspawn(move%20%7C%7C%20%7B%0A%20%20%20%20%20%20%20%20p.eat()%3B%0A%20%20%20%20%7D)%0A%7D).collect()%3B%0A%7D">Run</a></pre>

<p>Тут добавились трудные к пониманию пять строк кода. Давайте разбираться.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span><a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20handles%3A%20Vec%3C_%3E%20%3D%0A%7D">Run</a></pre>

<p>Объявляем новое связанное имя <code>handles</code>. Мы задали такое имя, потому что
собираемся создать несколько потоков, в результате чего получим для них
дескрипторы, с помощью которых сможем контролировать их выполнение. Здесь нам
нужно явно указать тип, а зачем это необходимо, мы расскажем чуть позже. <code>_</code> -
это заполнитель типа. Мы говорим компилятору «<code>handles</code> — это вектор, содержащий
элементы, тип которых Rust должен вывести самостоятельно».</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>philosophers</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> {<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Aphilosophers.into_iter().map(%7Cp%7C%20%7B%0A%7D">Run</a></pre>

<p>Мы берём наш список философов и вызываем метод <code>into_iter()</code>. Этот метод создаёт
итератор, который при каждой итерации забирает право владения на соответствующий
элемент. Это нужно для передачи элемента вектора в поток. Мы берём этот итератор
и вызываем метод <code>map</code>, который принимает замыкание в качестве аргумента и
вызывает это замыкание для каждого из элементов итератора.</p>

<pre class='rust rust-example-rendered'>
<span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
        <span class='ident'>p</span>.<span class='ident'>eat</span>();
    })<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Athread%3A%3Aspawn(move%20%7C%7C%20%7B%0A%20%20%20%20%20%20%20%20p.eat()%3B%0A%20%20%20%20%7D)%0A%7D">Run</a></pre>

<p>Вот здесь происходит сам параллелизм. Функция <code>thread::spawn</code> принимает в
качестве аргумента замыкание и исполняет это замыкание в новом потоке. Это
замыкание дополнительно нуждается в указании ключевого слова <code>move</code>, которое
сообщает, что это замыкание получает владение переменными, которые оно
захватывает. В данном случае — переменной <code>p</code> функции <code>map</code>.</p>

<p>Внутри потока мы всего лишь вызываем метод <code>eat()</code> переменной <code>p</code>. Также
обратите внимание, что вызов <code>thread::spawn</code> не оканчивается точкой с запятой,
что превращает его в выражение. Этот нюанс важен, так как возвращается
правильное значение. Для получения более подробной информации, прочитайте главу
<a href="functions.html#expressions-vs-statements">Выражения и операторы</a>.</p>

<pre class='rust rust-example-rendered'>
}).<span class='ident'>collect</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0A%7D).collect()%3B%0A%7D">Run</a></pre>

<p>По завершении мы получаем результат вызова <code>map</code> и собираем полученный результат
в коллекцию с помощью метода <code>collect()</code>. Метод <code>collect()</code> создаёт коллекцию
какого-то типа, и для того, чтобы Rust понял, коллекцию какого типа мы хотим
получить, мы указали для <code>handle</code> тип принимаемого значения <code>Vec&lt;T&gt;</code>. Элементами
коллекции будут возвращаемые из методов <code>thread::spawn</code> значения, которые
являются дескрипторами этих потоков. Вот так!</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>for</span> <span class='ident'>h</span> <span class='kw'>in</span> <span class='ident'>handles</span> {
    <span class='ident'>h</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>();
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afor%20h%20in%20handles%20%7B%0A%20%20%20%20h.join().unwrap()%3B%0A%7D%0A%7D">Run</a></pre>

<p>В конце функции <code>main()</code> мы в цикле перебираем каждый дескриптор и вызываем для
него метод <code>join()</code>, который блокирует дальнейшее исполнение основного потока,
пока не завершится дочерний поток. Это позволяет нам быть уверенными, что потоки
завершат работу до того как произойдёт выход из программы.</p>

<p>Если вы запустите эту программу, то вы увидите, что философы едят не дожидаясь
своей очереди! У нас многопоточность!</p>

<pre><code class="language-text">Джудит Батлер начала есть.
Рая Дунаевская начала есть.
Зарубина Наталья начала есть.
Эмма Гольдман начала есть.
Анна Шмидт начала есть.
Джудит Батлер закончила есть.
Рая Дунаевская закончила есть.
Зарубина Наталья закончила есть.
Эмма Гольдман закончила есть.
Анна Шмидт закончила есть.
</code></pre>

<p>Но как же быть с вилками? Их мы пока ещё не смоделировали.</p>

<p>Давайте же начнём. Сначала сделаем новую структуру:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::<span class='ident'>Mutex</span>;

<span class='kw'>struct</span> <span class='ident'>Table</span> {
    <span class='ident'>forks</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Mutex</span><span class='op'>&lt;</span>()<span class='op'>&gt;&gt;</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3AMutex%3B%0A%0Astruct%20Table%20%7B%0A%20%20%20%20forks%3A%20Vec%3CMutex%3C()%3E%3E%2C%0A%7D%0A%7D">Run</a></pre>

<p>Структура <code>Table</code> содержит вектор мьютексов (<code>Mutex</code>). Мьютекс — способ
управления доступом к данным для параллельно выполняющихся потоков: только один
поток может получить доступ к данным в конкретный момент времени. Это именно то
свойство, которое нужно для реализации наших вилок. В коде мы используем пустой
кортеж, <code>()</code>, внутри мьютекса, так как не собираемся использовать это значение,
а мьютекс используется только для организации доступа.</p>

<p>Давайте изменим программу, используя структуру <code>Table</code>:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>thread</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>time</span>::<span class='ident'>Duration</span>;
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Mutex</span>, <span class='ident'>Arc</span>};

<span class='kw'>struct</span> <span class='ident'>Philosopher</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>left</span>: <span class='ident'>usize</span>,
    <span class='ident'>right</span>: <span class='ident'>usize</span>,
}

<span class='kw'>impl</span> <span class='ident'>Philosopher</span> {
    <span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>left</span>: <span class='ident'>usize</span>, <span class='ident'>right</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {
        <span class='ident'>Philosopher</span> {
            <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
            <span class='ident'>left</span>: <span class='ident'>left</span>,
            <span class='ident'>right</span>: <span class='ident'>right</span>,
        }
    }

    <span class='kw'>fn</span> <span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>table</span>: <span class='kw-2'>&amp;</span><span class='ident'>Table</span>) {
        <span class='kw'>let</span> <span class='ident'>_left</span> <span class='op'>=</span> <span class='ident'>table</span>.<span class='ident'>forks</span>[<span class='self'>self</span>.<span class='ident'>left</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
        <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>150</span>));
        <span class='kw'>let</span> <span class='ident'>_right</span> <span class='op'>=</span> <span class='ident'>table</span>.<span class='ident'>forks</span>[<span class='self'>self</span>.<span class='ident'>right</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} начала есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);

        <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>1000</span>));

        <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} закончила есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);
    }
}

<span class='kw'>struct</span> <span class='ident'>Table</span> {
    <span class='ident'>forks</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span><span class='ident'>Mutex</span><span class='op'>&lt;</span>()<span class='op'>&gt;&gt;</span>,
}

<span class='kw'>fn</span> <span class='ident'>main</span>() {
    <span class='kw'>let</span> <span class='ident'>table</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Table</span> { <span class='ident'>forks</span>: <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
    ]});

    <span class='kw'>let</span> <span class='ident'>philosophers</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Джудит Батлер&quot;</span>, <span class='number'>0</span>, <span class='number'>1</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Рая Дунаевская&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Зарубина Наталья&quot;</span>, <span class='number'>2</span>, <span class='number'>3</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Эмма Гольдман&quot;</span>, <span class='number'>3</span>, <span class='number'>4</span>),
        <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Анна Шмидт&quot;</span>, <span class='number'>0</span>, <span class='number'>4</span>),
    ];

    <span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>philosophers</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> {
        <span class='kw'>let</span> <span class='ident'>table</span> <span class='op'>=</span> <span class='ident'>table</span>.<span class='ident'>clone</span>();

        <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
            <span class='ident'>p</span>.<span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='ident'>table</span>);
        })
    }).<span class='ident'>collect</span>();

    <span class='kw'>for</span> <span class='ident'>h</span> <span class='kw'>in</span> <span class='ident'>handles</span> {
        <span class='ident'>h</span>.<span class='ident'>join</span>().<span class='ident'>unwrap</span>();
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=use%20std%3A%3Athread%3B%0Ause%20std%3A%3Atime%3A%3ADuration%3B%0Ause%20std%3A%3Async%3A%3A%7BMutex%2C%20Arc%7D%3B%0A%0Astruct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20left%3A%20usize%2C%0A%20%20%20%20right%3A%20usize%2C%0A%7D%0A%0Aimpl%20Philosopher%20%7B%0A%20%20%20%20fn%20new(name%3A%20%26str%2C%20left%3A%20usize%2C%20right%3A%20usize)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20left%3A%20left%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20right%3A%20right%2C%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20eat(%26self%2C%20table%3A%20%26Table)%20%7B%0A%20%20%20%20%20%20%20%20let%20_left%20%3D%20table.forks%5Bself.left%5D.lock().unwrap()%3B%0A%20%20%20%20%20%20%20%20thread%3A%3Asleep(Duration%3A%3Afrom_millis(150))%3B%0A%20%20%20%20%20%20%20%20let%20_right%20%3D%20table.forks%5Bself.right%5D.lock().unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%0A%20%20%20%20%20%20%20%20thread%3A%3Asleep(Duration%3A%3Afrom_millis(1000))%3B%0A%0A%20%20%20%20%20%20%20%20println!(%22%7B%7D%20%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%20%20%20%20%7D%0A%7D%0A%0Astruct%20Table%20%7B%0A%20%20%20%20forks%3A%20Vec%3CMutex%3C()%3E%3E%2C%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20table%20%3D%20Arc%3A%3Anew(Table%20%7B%20forks%3A%20vec!%5B%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%5D%7D)%3B%0A%0A%20%20%20%20let%20philosophers%20%3D%20vec!%5B%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22%2C%200%2C%201)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22%2C%201%2C%202)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22%2C%202%2C%203)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22%2C%203%2C%204)%2C%0A%20%20%20%20%20%20%20%20Philosopher%3A%3Anew(%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22%2C%200%2C%204)%2C%0A%20%20%20%20%5D%3B%0A%0A%20%20%20%20let%20handles%3A%20Vec%3C_%3E%20%3D%20philosophers.into_iter().map(%7Cp%7C%20%7B%0A%20%20%20%20%20%20%20%20let%20table%20%3D%20table.clone()%3B%0A%0A%20%20%20%20%20%20%20%20thread%3A%3Aspawn(move%20%7C%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20p.eat(%26table)%3B%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%7D).collect()%3B%0A%0A%20%20%20%20for%20h%20in%20handles%20%7B%0A%20%20%20%20%20%20%20%20h.join().unwrap()%3B%0A%20%20%20%20%7D%0A%7D%0A">Run</a></pre>

<p>Много изменений! Однако, с этими изменениями мы получили корректно работающую
программу. Приступим к рассмотрению:</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>use</span> <span class='ident'>std</span>::<span class='ident'>sync</span>::{<span class='ident'>Mutex</span>, <span class='ident'>Arc</span>};<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Ause%20std%3A%3Async%3A%3A%7BMutex%2C%20Arc%7D%3B%0A%7D">Run</a></pre>

<p>Нам далее понадобится структура <code>Arc&lt;T&gt;</code> из модуля стандартной библиотеки
<code>std::sync</code>. Мы поговорим о ней чуть позже.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>struct</span> <span class='ident'>Philosopher</span> {
    <span class='ident'>name</span>: <span class='ident'>String</span>,
    <span class='ident'>left</span>: <span class='ident'>usize</span>,
    <span class='ident'>right</span>: <span class='ident'>usize</span>,
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Astruct%20Philosopher%20%7B%0A%20%20%20%20name%3A%20String%2C%0A%20%20%20%20left%3A%20usize%2C%0A%20%20%20%20right%3A%20usize%2C%0A%7D%0A%7D">Run</a></pre>

<p>Нам понадобилось добавить ещё два поля в нашу структуру <code>Philosopher</code>. Каждый
философ должен иметь две вилки: одну — для левой руки, другую — для правой руки.
Мы используем тип <code>usize</code> для идентификации каждой вилки. Мы используем его при
создании философа, передавая идентификаторы двух вилок. Эти два значения будут
использоваться полем <code>forks</code> структуры <code>Table</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>new</span>(<span class='ident'>name</span>: <span class='kw-2'>&amp;</span><span class='ident'>str</span>, <span class='ident'>left</span>: <span class='ident'>usize</span>, <span class='ident'>right</span>: <span class='ident'>usize</span>) <span class='op'>-&gt;</span> <span class='ident'>Philosopher</span> {
    <span class='ident'>Philosopher</span> {
        <span class='ident'>name</span>: <span class='ident'>name</span>.<span class='ident'>to_string</span>(),
        <span class='ident'>left</span>: <span class='ident'>left</span>,
        <span class='ident'>right</span>: <span class='ident'>right</span>,
    }
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20new(name%3A%20%26str%2C%20left%3A%20usize%2C%20right%3A%20usize)%20-%3E%20Philosopher%20%7B%0A%20%20%20%20Philosopher%20%7B%0A%20%20%20%20%20%20%20%20name%3A%20name.to_string()%2C%0A%20%20%20%20%20%20%20%20left%3A%20left%2C%0A%20%20%20%20%20%20%20%20right%3A%20right%2C%0A%20%20%20%20%7D%0A%7D%0A%7D">Run</a></pre>

<p>Мы используем функцию <code>new()</code> для задания значений <code>left</code> и <code>right</code>.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>fn</span> <span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='self'>self</span>, <span class='ident'>table</span>: <span class='kw-2'>&amp;</span><span class='ident'>Table</span>) {
    <span class='kw'>let</span> <span class='ident'>_left</span> <span class='op'>=</span> <span class='ident'>table</span>.<span class='ident'>forks</span>[<span class='self'>self</span>.<span class='ident'>left</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();
    <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>150</span>));
    <span class='kw'>let</span> <span class='ident'>_right</span> <span class='op'>=</span> <span class='ident'>table</span>.<span class='ident'>forks</span>[<span class='self'>self</span>.<span class='ident'>right</span>].<span class='ident'>lock</span>().<span class='ident'>unwrap</span>();

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} начала есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);

    <span class='ident'>thread</span>::<span class='ident'>sleep</span>(<span class='ident'>Duration</span>::<span class='ident'>from_millis</span>(<span class='number'>1000</span>));

    <span class='macro'>println</span><span class='macro'>!</span>(<span class='string'>&quot;{} закончила есть.&quot;</span>, <span class='self'>self</span>.<span class='ident'>name</span>);
}<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Afn%20eat(%26self%2C%20table%3A%20%26Table)%20%7B%0A%20%20%20%20let%20_left%20%3D%20table.forks%5Bself.left%5D.lock().unwrap()%3B%0A%20%20%20%20thread%3A%3Asleep(Duration%3A%3Afrom_millis(150))%3B%0A%20%20%20%20let%20_right%20%3D%20table.forks%5Bself.right%5D.lock().unwrap()%3B%0A%0A%20%20%20%20println!(%22%7B%7D%20%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%0A%20%20%20%20thread%3A%3Asleep(Duration%3A%3Afrom_millis(1000))%3B%0A%0A%20%20%20%20println!(%22%7B%7D%20%D0%B7%D0%B0%D0%BA%D0%BE%D0%BD%D1%87%D0%B8%D0%BB%D0%B0%20%D0%B5%D1%81%D1%82%D1%8C.%22%2C%20self.name)%3B%0A%7D%0A%7D">Run</a></pre>

<p>Здесь появились три новые строки. Мы добавили один аргумент, <code>table</code>. Мы
получаем доступ к списку вилок через структуру <code>Table</code>. Затем используем
идентификаторы вилок <code>self.left</code> и <code>self.right</code> для получения доступа к вилке по
определённому индексу. В результате чего мы получаем <code>Mutex</code>, который регулирует
доступ к вилке, и вызываем для него метод <code>lock()</code>, блокируя доступ к вилке.
Если в настоящее время доступ к вилке уже предоставлен кому-то ещё, то мы будем
блокированы, пока вилка не станет доступной. Мы также вызываем <code>thread::sleep</code>
между взятием первой и второй вилки, поскольку этот процесс не моментален.</p>

<p>Вызов метода <code>lock()</code> может потерпеть неудачу, и если это случается, то мы
аварийно завершаем работу программы. Может возникнуть ситуация, когда поток
аварийно завершит свою работу, а мьютекс при этом останется заблокированным.
Такой мьютекс называется «<a href="https://doc.rust-lang.org/stable/std/sync/struct.Mutex.html#poisoning">отравленным (poisoned)</a>». Но в нашем случае
это не может произойти, потому как мы просто используем метод <code>unwrap()</code>.</p>

<p>Результаты выполнения этих двух строк имеют имена <code>_left</code> и <code>_right</code>
соответственно. Зачем мы используем знаки подчёркивания в начале имён? Это для
того, чтобы сказать компилятору, что мы хотим получить значения, которые далее
<em>не планируем использовать</em>. Таким образом Rust не будет выводить предупреждение
о неиспользуемых именах.</p>

<p>Когда же мьютекс будет освобождён? Это произойдёт автоматически, когда <code>_left</code> и
<code>_right</code> выйдут из области видимости, то есть по окончании работы функции.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>table</span> <span class='op'>=</span> <span class='ident'>Arc</span>::<span class='ident'>new</span>(<span class='ident'>Table</span> { <span class='ident'>forks</span>: <span class='macro'>vec</span><span class='macro'>!</span>[
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
        <span class='ident'>Mutex</span>::<span class='ident'>new</span>(()),
    ]});<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20table%20%3D%20Arc%3A%3Anew(Table%20%7B%20forks%3A%20vec!%5B%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%20%20%20%20Mutex%3A%3Anew(())%2C%0A%20%20%20%20%5D%7D)%3B%0A%7D">Run</a></pre>

<p>Далее в <code>main()</code> мы создаём новый экземпляр структуры <code>Table</code> и оборачиваем его
в <code>Arc&lt;T&gt;</code>. Это «атомарный счётчик ссылок» (atomic reference count). Он нужен
для обеспечения доступа к нашей структуре <code>Table</code> из нескольких потоков. Когда
он передаётся в новый поток, то счётчик увеличивается, а когда этот поток
завершает работу, то счётчик уменьшается.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>philosophers</span> <span class='op'>=</span> <span class='macro'>vec</span><span class='macro'>!</span>[
    <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Джудит Батлер&quot;</span>, <span class='number'>0</span>, <span class='number'>1</span>),
    <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Рая Дунаевская&quot;</span>, <span class='number'>1</span>, <span class='number'>2</span>),
    <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Зарубина Наталья&quot;</span>, <span class='number'>2</span>, <span class='number'>3</span>),
    <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Эмма Гольдман&quot;</span>, <span class='number'>3</span>, <span class='number'>4</span>),
    <span class='ident'>Philosopher</span>::<span class='ident'>new</span>(<span class='string'>&quot;Анна Шмидт&quot;</span>, <span class='number'>0</span>, <span class='number'>4</span>),
];<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20philosophers%20%3D%20vec!%5B%0A%20%20%20%20Philosopher%3A%3Anew(%22%D0%94%D0%B6%D1%83%D0%B4%D0%B8%D1%82%20%D0%91%D0%B0%D1%82%D0%BB%D0%B5%D1%80%22%2C%200%2C%201)%2C%0A%20%20%20%20Philosopher%3A%3Anew(%22%D0%A0%D0%B0%D1%8F%20%D0%94%D1%83%D0%BD%D0%B0%D0%B5%D0%B2%D1%81%D0%BA%D0%B0%D1%8F%22%2C%201%2C%202)%2C%0A%20%20%20%20Philosopher%3A%3Anew(%22%D0%97%D0%B0%D1%80%D1%83%D0%B1%D0%B8%D0%BD%D0%B0%20%D0%9D%D0%B0%D1%82%D0%B0%D0%BB%D1%8C%D1%8F%22%2C%202%2C%203)%2C%0A%20%20%20%20Philosopher%3A%3Anew(%22%D0%AD%D0%BC%D0%BC%D0%B0%20%D0%93%D0%BE%D0%BB%D1%8C%D0%B4%D0%BC%D0%B0%D0%BD%22%2C%203%2C%204)%2C%0A%20%20%20%20Philosopher%3A%3Anew(%22%D0%90%D0%BD%D0%BD%D0%B0%20%D0%A8%D0%BC%D0%B8%D0%B4%D1%82%22%2C%200%2C%204)%2C%0A%5D%3B%0A%7D">Run</a></pre>

<p>Мы добавили наши значения <code>left</code> и <code>right</code> при создании структуры <code>Philosopher</code>.
Здесь есть <em>очень важная</em> деталь, на которую следует обратить внимание.
Посмотрите на последнюю строку создания <code>Philosopher</code>. Конструктор Анны Шмидт
должен был бы принимать в качестве аргументов значения <code>4</code> и <code>0</code>, но вместо
этого он принимает значения <code>0</code> и <code>4</code>. Это помешает нашей программе попасть в
безвыходное состояние, если каждый возьмёт по одной вилке одновременно. Так что
давайте представим, что один из философов у нас левша! Это один из способов
решить данную проблему, и, на мой взгляд, самый простой. Если вы поменяете
порядок параметров, то программа попадёт в безвыходное состояние.</p>

<pre class='rust rust-example-rendered'>
<span class='kw'>let</span> <span class='ident'>handles</span>: <span class='ident'>Vec</span><span class='op'>&lt;</span>_<span class='op'>&gt;</span> <span class='op'>=</span> <span class='ident'>philosophers</span>.<span class='ident'>into_iter</span>().<span class='ident'>map</span>(<span class='op'>|</span><span class='ident'>p</span><span class='op'>|</span> {
    <span class='kw'>let</span> <span class='ident'>table</span> <span class='op'>=</span> <span class='ident'>table</span>.<span class='ident'>clone</span>();

    <span class='ident'>thread</span>::<span class='ident'>spawn</span>(<span class='kw'>move</span> <span class='op'>||</span> {
        <span class='ident'>p</span>.<span class='ident'>eat</span>(<span class='kw-2'>&amp;</span><span class='ident'>table</span>);
    })
}).<span class='ident'>collect</span>();<a class="test-arrow" target="_blank" href="https://play.rust-lang.org/?code=fn%20main()%20%7B%0Alet%20handles%3A%20Vec%3C_%3E%20%3D%20philosophers.into_iter().map(%7Cp%7C%20%7B%0A%20%20%20%20let%20table%20%3D%20table.clone()%3B%0A%0A%20%20%20%20thread%3A%3Aspawn(move%20%7C%7C%20%7B%0A%20%20%20%20%20%20%20%20p.eat(%26table)%3B%0A%20%20%20%20%7D)%0A%7D).collect()%3B%0A%7D">Run</a></pre>

<p>Внутри нашего цикла <code>map()</code>/<code>collect()</code> мы вызываем метод <code>table.clone()</code>. Метод
<code>clone()</code> структуры <code>Arc&lt;T&gt;</code> клонирует значение и инкрементирует счётчик,
который автоматически декрементируется, когда клонированное значение покинет
область видимости. Это необходимо для того, чтобы мы знали, как много ссылок на
<code>table</code> существуют в рамках наших потоков на данный момент времени. Если бы у
нас не было подсчёта ссылок, то мы бы не знали, как и когда освободить хранимое
значение.</p>

<p>Вы можете заметить, что здесь мы выполняем новое связывание с именем <code>table</code>,
затеняя старое связанное имя <code>table</code>. Это позволяет нам не вводить новое
уникальное имя.</p>

<p>Теперь наша программа работает! Только два философа могут обедать одновременно.
После запуска программы вы можете получить такой результат.</p>

<pre><code class="language-text">Рая Дунаевская начала есть.
Эмма Гольдман начала есть.
Эмма Гольдман закончила есть.
Рая Дунаевская закончила есть.
Джудит Батлер начала есть.
Зарубина Наталья начала есть.
Джудит Батлер закончила есть.
Анна Шмидт начала есть.
Зарубина Наталья закончила есть.
Анна Шмидт закончила есть.
</code></pre>

<p>Поздравляем! Вы реализовали классическую задачу параллелизма на языке Rust.</p>

    <script src='../rustbook.js'></script>
</div></div>


</body>
</html>